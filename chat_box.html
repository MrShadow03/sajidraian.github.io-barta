<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BARTA â€” Chat</title>
  <link rel="stylesheet" href="https://maxst.icons8.com/vue-static/landings/line-awesome/line-awesome/1.3.0/css/line-awesome.min.css" />
  <link rel="stylesheet" href="style.css" />
  <style>
    .online-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #4caf50;
      position: absolute;
      bottom: 2px;
      right: 2px;
      border: 2px solid var(--sidebar);
    }
    .offline-indicator {
      background: var(--muted);
    }
    .user {
      position: relative;
    }
    .logout-btn {
      margin-top: auto;
      width: 100%;
    }
    .typing-indicator {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 12px 14px;
      margin: 8px 0;
      background: var(--bubble-left);
      border-radius: 12px;
      border-bottom-left-radius: 4px;
      width: fit-content;
      max-width: 65%;
    }
    .typing-indicator.active {
      display: flex;
    }
    .typing-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
      animation: typingBounce 1.4s infinite ease-in-out;
    }
    .typing-dot:nth-child(1) {
      animation-delay: 0s;
    }
    .typing-dot:nth-child(2) {
      animation-delay: 0.2s;
    }
    .typing-dot:nth-child(3) {
      animation-delay: 0.4s;
    }
    @keyframes typingBounce {
      0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.7;
      }
      30% {
        transform: translateY(-10px);
        opacity: 1;
      }
    }
    
    /* Call Modal Styles */
    .call-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    .call-modal.active {
      display: flex;
    }
    .call-modal-content {
      text-align: center;
      color: white;
      max-width: 500px;
      width: 90%;
    }
    .call-video-container {
      position: relative;
      width: 100%;
      max-width: 800px;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      margin: 20px 0;
    }
    #remoteVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #localVideo {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 150px;
      height: 112px;
      border-radius: 8px;
      border: 2px solid var(--accent);
      object-fit: cover;
      background: #000;
    }
    .call-info {
      margin: 20px 0;
    }
    .call-user-name {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 8px;
    }
    .call-status {
      font-size: 16px;
      color: #aaa;
      margin-bottom: 5px;
    }
    .call-duration {
      font-size: 14px;
      color: #888;
    }
    .call-controls {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 30px;
    }
    .call-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      color: white;
    }
    .call-btn:hover {
      transform: scale(1.1);
    }
    .call-btn-mute {
      background: #444;
    }
    .call-btn-mute.active {
      background: #ff4444;
    }
    .call-btn-video {
      background: #444;
    }
    .call-btn-video.active {
      background: #ff4444;
    }
    .call-btn-end {
      background: #ff4444;
      width: 70px;
      height: 70px;
      font-size: 28px;
    }
    .call-btn-accept {
      background: #4caf50;
      width: 70px;
      height: 70px;
      font-size: 28px;
    }
    .call-btn-reject {
      background: #ff4444;
      width: 70px;
      height: 70px;
      font-size: 28px;
    }
    .incoming-call-avatar {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      margin: 20px auto;
      border: 4px solid var(--accent);
    }
    .ringing-animation {
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.05);
        opacity: 0.8;
      }
    }
  </style>
</head>
<body class="app">
  <!-- Call Modal -->
  <div class="call-modal" id="callModal">
    <div class="call-modal-content">
      <!-- Incoming Call UI -->
      <div id="incomingCallUI" style="display: none;">
        <img id="incomingCallAvatar" class="incoming-call-avatar ringing-animation" src="" alt="Caller" />
        <div class="call-info">
          <div class="call-user-name" id="incomingCallName"></div>
          <div class="call-status" id="incomingCallType"></div>
        </div>
        <div class="call-controls">
          <button class="call-btn call-btn-accept" id="acceptCallBtn" title="Accept">
            <i class="las la-phone"></i>
          </button>
          <button class="call-btn call-btn-reject" id="rejectCallBtn" title="Reject">
            <i class="las la-phone-slash"></i>
          </button>
        </div>
      </div>
      
      <!-- Outgoing Call UI -->
      <div id="outgoingCallUI" style="display: none;">
        <img id="outgoingCallAvatar" class="incoming-call-avatar ringing-animation" src="" alt="Receiver" />
        <div class="call-info">
          <div class="call-user-name" id="outgoingCallName"></div>
          <div class="call-status">Calling...</div>
        </div>
        <div class="call-controls">
          <button class="call-btn call-btn-end" id="cancelCallBtn" title="Cancel">
            <i class="las la-phone-slash"></i>
          </button>
        </div>
      </div>
      
      <!-- Active Call UI -->
      <div id="activeCallUI" style="display: none;">
        <div class="call-video-container">
          <video id="remoteVideo" autoplay playsinline></video>
          <video id="localVideo" autoplay playsinline muted></video>
        </div>
        <div class="call-info">
          <div class="call-user-name" id="activeCallName"></div>
          <div class="call-duration" id="callDuration">00:00</div>
        </div>
        <div class="call-controls">
          <button class="call-btn call-btn-mute" id="muteBtn" title="Mute">
            <i class="las la-microphone"></i>
          </button>
          <button class="call-btn call-btn-video" id="videoBtn" title="Video" style="display: none;">
            <i class="las la-video"></i>
          </button>
          <button class="call-btn call-btn-end" id="endCallBtn" title="End Call">
            <i class="las la-phone-slash"></i>
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
    <span class="theme-icon" id="themeIcon">ðŸŒ™</span>
  </button>
  
  <div class="layout">
    <aside class="sidebar">
      <div class="sidebar-top">
        <div class="profile">
          <img id="currentUserPhoto" src="avater/luffy.jpg" alt="profile" class="avatar" />
          <div class="profile-meta">
            <div class="app-name">BARTA</div>
            <div class="status" id="currentUsername">online</div>
          </div>
        </div>

        <div class="searchbox">
          <input class="search-input" placeholder="Search users" id="searchInput" aria-label="Search conversations" />
        </div>
      </div>

      <nav class="user-list" aria-label="Conversations" id="userList">
        <!-- Users will be loaded here -->
      </nav>

      <footer class="sidebar-footer">
        <button class="btn btn-ghost logout-btn" id="logoutBtn">Logout</button>
      </footer>
    </aside>

    <main class="chat-area" id="chatArea">
      <div class="empty-chat">
        <div class="empty-inner">
          <h2>Welcome to BARTA</h2>
          <p>Select a user to start chatting</p>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Dynamic API URL - works for both local and Railway deployment
    const API_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      ? 'http://localhost:3000/api'
      : `${window.location.protocol}//${window.location.host}/api`;
    
    console.log('API URL:', API_URL);
    
    let currentUserId = localStorage.getItem('userId');
    let currentUsername = localStorage.getItem('username');
    let sessionId = localStorage.getItem('sessionId');
    let selectedUserId = null;
    let selectedUsername = null;
    let lastMessageId = null;
    let userListInterval = null;
    let messagesInterval = null;
    let typingTimeout = null;
    let lastTypingState = false;
    
    // WebRTC Call Variables
    let peerConnection = null;
    let localStream = null;
    let remoteStream = null;
    let currentCallId = null;
    let currentCallType = null;
    let callCheckInterval = null;
    let callDurationInterval = null;
    let callStartTime = null;
    let lastIceCheckTimestamp = 0;
    let ringtoneInterval = null;
    let isSettingUpCall = false; // Prevent race conditions during setup
    
    const configuration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };
    
    // Check if logged in
    if (!sessionId || !currentUserId) {
      window.location.href = 'login.html';
    }
    
    // Sound Effects System
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      if (type === 'send') {
        oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
        oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.05);
        gainNode.gain.setValueAtTime(0.12, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.15);
      } else if (type === 'receive') {
        oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
        oscillator.frequency.setValueAtTime(700, audioCtx.currentTime + 0.05);
        gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.15);
      } else if (type === 'click') {
        oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.1);
      } else if (type === 'toggle') {
        oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
        oscillator.frequency.setValueAtTime(900, audioCtx.currentTime + 0.05);
        gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.15);
      }
    }
    
    // Call Sound Effects
    function playRingtone() {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
      oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime + 0.2);
      gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + 0.4);
    }
    
    function startRingtone() {
      stopRingtone();
      playRingtone();
      ringtoneInterval = setInterval(playRingtone, 2000);
    }
    
    function stopRingtone() {
      if (ringtoneInterval) {
        clearInterval(ringtoneInterval);
        ringtoneInterval = null;
      }
    }
    
    function playCallConnected() {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
      oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
      oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime + 0.2);
      gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + 0.3);
    }
    
    function playCallEnded() {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
      oscillator.frequency.setValueAtTime(400, audioCtx.currentTime + 0.15);
      gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + 0.3);
    }
    
    // Theme toggle functionality
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = document.getElementById('themeIcon');
    const html = document.documentElement;
    
    const savedTheme = localStorage.getItem('theme') || 'dark';
    html.setAttribute('data-theme', savedTheme);
    themeIcon.innerHTML = savedTheme === 'light' ? '<i class="las la-moon"></i>' : '<i class="las la-sun"></i>';
    
    themeToggle.addEventListener('click', () => {
      playSound('toggle');
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      themeIcon.innerHTML = newTheme === 'light' ? '<i class="las la-moon"></i>' : '<i class="las la-sun"></i>';
    });
    
    // Set current user info
    document.getElementById('currentUsername').textContent = currentUsername;
    document.getElementById('currentUserPhoto').src = localStorage.getItem('userPhoto') || 'avater/luffy.jpg';
    
    // Heartbeat to keep session alive
    async function sendHeartbeat() {
      try {
        await fetch(`${API_URL}/heartbeat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId })
        });
      } catch (err) {
        console.error('Heartbeat error:', err);
      }
    }
    
    setInterval(sendHeartbeat, 30000); // Every 30 seconds
    
    // Load user list
    async function loadUsers() {
      try {
        console.log('[LOAD USERS] Fetching users for:', currentUserId);
        console.log('[LOAD USERS] API URL:', `${API_URL}/users?currentUserId=${currentUserId}`);
        
        const response = await fetch(`${API_URL}/users?currentUserId=${currentUserId}`, {
          signal: AbortSignal.timeout(5000) // 5 second timeout
        });
        
        if (!response.ok) {
          console.error('[LOAD USERS] HTTP error:', response.status, response.statusText);
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const users = await response.json();
        console.log('[LOAD USERS] Received users:', users.length, users);
        
        const userList = document.getElementById('userList');
        const searchQuery = document.getElementById('searchInput').value.toLowerCase();
        
        const filteredUsers = users.filter(u => 
          u.username.toLowerCase().includes(searchQuery)
        );
        
        console.log('[LOAD USERS] Filtered users:', filteredUsers.length);
        
        // Only update if there's a change
        const currentUserIds = Array.from(userList.querySelectorAll('.user')).map(u => u.dataset.userId);
        const newUserIds = filteredUsers.map(u => u.id);
        
        if (JSON.stringify(currentUserIds) !== JSON.stringify(newUserIds) || searchQuery) {
          userList.innerHTML = '';
          
          filteredUsers.forEach(user => {
            const userDiv = document.createElement('div');
            userDiv.className = 'user';
            userDiv.dataset.userId = user.id;
            userDiv.setAttribute('role', 'button');
            userDiv.setAttribute('tabindex', '0');
            userDiv.setAttribute('aria-label', `Chat with ${user.username}`);
            
            if (selectedUserId === user.id) {
              userDiv.classList.add('active');
            }
            
            userDiv.innerHTML = `
              <img src="${user.photo}" alt="${user.username} profile picture" />
              <span>${user.username}</span>
              <span class="${user.online ? 'online-indicator' : 'online-indicator offline-indicator'}"></span>
            `;
            
            userDiv.addEventListener('click', () => selectUser(user));
            userList.appendChild(userDiv);
          });
        } else {
          // Update online status indicators
          filteredUsers.forEach(user => {
            const userDiv = userList.querySelector(`[data-user-id="${user.id}"]`);
            if (userDiv) {
              const indicator = userDiv.querySelector('.online-indicator');
              if (indicator) {
                indicator.className = user.online ? 'online-indicator' : 'online-indicator offline-indicator';
              }
            }
          });
        }
      } catch (err) {
        console.error('Error loading users:', err);
      }
    }
    
    // Select user to chat
    function selectUser(user) {
      playSound('click');
      selectedUserId = user.id;
      selectedUsername = user.username;
      lastMessageId = null;
      
      // Update UI
      document.querySelectorAll('.user').forEach(u => u.classList.remove('active'));
      document.querySelector(`[data-user-id="${user.id}"]`)?.classList.add('active');
      
      // Show chat interface
      const chatArea = document.getElementById('chatArea');
      chatArea.innerHTML = `
        <header class="chat-topbar">
          <div class="chat-person">
            <img src="${user.photo}" alt="avatar" class="avatar-sm" />
            <div class="chat-person-meta">
              <div class="chat-name">${user.username}</div>
              <div class="chat-sub">${user.online ? 'online' : 'offline'}</div>
            </div>
          </div>
          <div class="chat-actions">
            <button class="icon-btn" title="Call" aria-label="Start voice call"><i class="las la-phone"></i></button>
            <button class="icon-btn" title="Video" aria-label="Start video call"><i class="las la-video"></i></button>
            <button class="icon-btn" title="More" aria-label="More options"><i class="las la-ellipsis-v"></i></button>
          </div>
        </header>
        
        <section id="messages" class="messages" role="log" aria-live="polite" aria-label="Chat messages">
          <div class="typing-indicator" id="typingIndicator">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
          </div>
        </section>
        
        <footer class="composer">
          <input id="msgInput" class="composer-input" type="text" placeholder="Write a messageâ€¦" aria-label="Message input" />
          <button id="sendBtn" class="btn btn-send" aria-label="Send message"><i class="las la-paper-plane"></i></button>
        </footer>
      `;
      
      // Setup message handlers
      setupMessageHandlers();
      
      // Add call button functionality
      addCallButtons();
      
      // Load messages
      loadMessages();
      
      // Start polling for new messages
      if (messagesInterval) clearInterval(messagesInterval);
      messagesInterval = setInterval(loadMessages, 2000);
    }
    
    // Load messages
    async function loadMessages() {
      if (!selectedUserId) return;
      
      try {
        // Check if other user is typing
        checkTypingStatus();
        
        const url = lastMessageId 
          ? `${API_URL}/messages/${currentUserId}/${selectedUserId}?lastMessageId=${lastMessageId}`
          : `${API_URL}/messages/${currentUserId}/${selectedUserId}`;
          
        const response = await fetch(url);
        const messages = await response.json();
        
        if (messages.length > 0) {
          const messagesContainer = document.getElementById('messages');
          
          messages.forEach(msg => {
            appendMessage(
              msg.senderId === currentUserId ? 'right' : 'left',
              msg.text,
              formatTime(msg.timestamp),
              msg.id
            );
            
            lastMessageId = msg.id;
            
            // Play sound for received messages
            if (msg.senderId !== currentUserId) {
              playSound('receive');
            }
          });
          
          // Mark messages as read
          if (messages.some(m => m.senderId === selectedUserId)) {
            await fetch(`${API_URL}/messages/read`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ userId: currentUserId, senderId: selectedUserId })
            });
          }
        }
      } catch (err) {
        console.error('Error loading messages:', err);
      }
    }
    
    // Append message to chat
    function appendMessage(side, text, time, msgId) {
      const messagesContainer = document.getElementById('messages');
      if (!messagesContainer) return;
      
      // Check if message already exists
      if (msgId && messagesContainer.querySelector(`[data-msg-id="${msgId}"]`)) {
        return;
      }
      
      const div = document.createElement('div');
      div.className = 'msg ' + side;
      div.dataset.msgId = msgId;
      
      const textDiv = document.createElement('div');
      textDiv.className = 'msg-text';
      textDiv.textContent = text;
      
      const timeDiv = document.createElement('div');
      timeDiv.className = 'msg-time';
      timeDiv.textContent = time;
      
      div.appendChild(textDiv);
      div.appendChild(timeDiv);
      
      // Insert before typing indicator
      const typingIndicator = document.getElementById('typingIndicator');
      if (typingIndicator) {
        messagesContainer.insertBefore(div, typingIndicator);
      } else {
        messagesContainer.appendChild(div);
      }
      
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    // Format timestamp
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      let hours = date.getHours();
      const minutes = date.getMinutes();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12;
      hours = hours ? hours : 12;
      const minutesStr = minutes < 10 ? '0' + minutes : minutes;
      return hours + ':' + minutesStr + ' ' + ampm;
    }
    
    // Check if other user is typing
    async function checkTypingStatus() {
      if (!selectedUserId) return;
      
      try {
        const response = await fetch(`${API_URL}/typing/${selectedUserId}/${currentUserId}`);
        const data = await response.json();
        
        const typingIndicator = document.getElementById('typingIndicator');
        if (typingIndicator) {
          if (data.isTyping) {
            typingIndicator.classList.add('active');
          } else {
            // Add delay before hiding
            setTimeout(() => {
              typingIndicator.classList.remove('active');
            }, 800);
          }
        }
      } catch (err) {
        console.error('Error checking typing status:', err);
      }
    }
    
    // Send typing indicator
    async function sendTypingIndicator(isTyping) {
      if (!selectedUserId || lastTypingState === isTyping) return;
      
      lastTypingState = isTyping;
      
      try {
        await fetch(`${API_URL}/typing`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userId: currentUserId,
            receiverId: selectedUserId,
            isTyping
          })
        });
      } catch (err) {
        console.error('Error sending typing indicator:', err);
      }
    }
    
    // Setup message input handlers
    function setupMessageHandlers() {
      const msgInput = document.getElementById('msgInput');
      const sendBtn = document.getElementById('sendBtn');
      
      async function sendMessage() {
        const text = msgInput.value.trim();
        if (!text) {
          msgInput.style.borderColor = '#ff4444';
          setTimeout(() => { msgInput.style.borderColor = ''; }, 500);
          return;
        }
        
        // Stop typing indicator
        sendTypingIndicator(false);
        if (typingTimeout) clearTimeout(typingTimeout);
        
        playSound('send');
        
        msgInput.disabled = true;
        sendBtn.disabled = true;
        sendBtn.style.opacity = '0.6';
        
        try {
          const response = await fetch(`${API_URL}/messages`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              senderId: currentUserId,
              receiverId: selectedUserId,
              text
            })
          });
          
          const data = await response.json();
          
          if (response.ok) {
            appendMessage('right', text, formatTime(data.message.timestamp), data.message.id);
            lastMessageId = data.message.id;
            msgInput.value = '';
          }
        } catch (err) {
          console.error('Error sending message:', err);
        } finally {
          msgInput.disabled = false;
          sendBtn.disabled = false;
          sendBtn.style.opacity = '1';
          msgInput.focus();
        }
      }
      
      sendBtn.addEventListener('click', sendMessage);
      msgInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') sendMessage();
      });
      
      // Typing indicator
      msgInput.addEventListener('input', () => {
        sendTypingIndicator(true);
        
        // Clear previous timeout
        if (typingTimeout) clearTimeout(typingTimeout);
        
        // Stop typing after 2 seconds of inactivity
        typingTimeout = setTimeout(() => {
          sendTypingIndicator(false);
        }, 2000);
      });
      
      msgInput.addEventListener('blur', () => {
        sendTypingIndicator(false);
      });
    }
    
    // Search users
    document.getElementById('searchInput').addEventListener('input', loadUsers);
    
    // Logout
    document.getElementById('logoutBtn').addEventListener('click', async () => {
      // Confirm if in a call
      if (currentCallId) {
        const confirmLogout = confirm('You are currently in a call. Are you sure you want to logout?');
        if (!confirmLogout) return;
        
        // End the call first
        await endCall();
      }
      
      // Show logout in progress
      const logoutBtn = document.getElementById('logoutBtn');
      const originalText = logoutBtn.textContent;
      logoutBtn.textContent = 'Logging out...';
      logoutBtn.disabled = true;
      
      try {
        // Clear all intervals
        if (userListInterval) clearInterval(userListInterval);
        if (messagesInterval) clearInterval(messagesInterval);
        
        // Cleanup call resources
        cleanupCall();
        
        // Logout on server
        await fetch(`${API_URL}/logout`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sessionId })
        });
        
        // Clear local storage
        localStorage.removeItem('sessionId');
        localStorage.removeItem('userId');
        localStorage.removeItem('username');
        localStorage.removeItem('userPhoto');
        
        // Redirect to login
        window.location.href = 'login.html';
      } catch (err) {
        console.error('Logout error:', err);
        
        // Still logout locally even if server request fails
        localStorage.removeItem('sessionId');
        localStorage.removeItem('userId');
        localStorage.removeItem('username');
        localStorage.removeItem('userPhoto');
        window.location.href = 'login.html';
      }
    });
    
    // ============ WebRTC Call Functions ============
    
    // Initialize WebRTC Peer Connection
    async function createPeerConnection() {
      peerConnection = new RTCPeerConnection(configuration);
      
      // Add local stream tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });
      }
      
      // Handle remote stream
      peerConnection.ontrack = (event) => {
        if (!remoteStream) {
          remoteStream = new MediaStream();
          document.getElementById('remoteVideo').srcObject = remoteStream;
        }
        remoteStream.addTrack(event.track);
      };
      
      // Handle ICE candidates
      peerConnection.onicecandidate = async (event) => {
        if (event.candidate && currentCallId) {
          try {
            await fetch(`${API_URL}/call/ice-candidate`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                callId: currentCallId,
                candidate: event.candidate,
                userId: currentUserId
              })
            });
          } catch (err) {
            console.error('Error sending ICE candidate:', err);
          }
        }
      };
      
      // Handle connection state changes
      peerConnection.onconnectionstatechange = () => {
        console.log('Connection state:', peerConnection.connectionState);
        if (peerConnection.connectionState === 'connected') {
          stopRingtone();
          playCallConnected();
          showActiveCallUI();
          startCallDuration();
        } else if (peerConnection.connectionState === 'disconnected' || 
                   peerConnection.connectionState === 'failed') {
          console.log('Connection failed or disconnected');
          endCall();
        }
      };
      
      // Also handle ICE connection state as backup
      peerConnection.oniceconnectionstatechange = () => {
        console.log('ICE connection state:', peerConnection.iceConnectionState);
        
        if (peerConnection.iceConnectionState === 'connected' || 
            peerConnection.iceConnectionState === 'completed') {
          // Ensure UI is shown even if connectionState didn't trigger
          if (document.getElementById('outgoingCallUI').style.display !== 'none' ||
              document.getElementById('incomingCallUI').style.display !== 'none') {
            stopRingtone();
            playCallConnected();
            showActiveCallUI();
            startCallDuration();
          }
        } else if (peerConnection.iceConnectionState === 'failed' || 
                   peerConnection.iceConnectionState === 'disconnected') {
          console.log('ICE connection failed');
          setTimeout(() => {
            if (peerConnection && peerConnection.iceConnectionState === 'failed') {
              endCall();
            }
          }, 3000); // Give it 3 seconds to recover
        }
      };
    }
    
    // Start a call (audio or video)
    async function startCall(callType) {
      if (!selectedUserId) {
        alert('Please select a user to call');
        return;
      }
      
      if (isSettingUpCall) {
        console.log('Call setup already in progress');
        return;
      }
      
      isSettingUpCall = true;
      console.log('Starting', callType, 'call to user:', selectedUserId);
      
      // Send immediate heartbeat to ensure session is active
      await sendHeartbeat();
      
      try {
        currentCallType = callType;
        
        // Get user media
        const constraints = {
          audio: true,
          video: callType === 'video'
        };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        document.getElementById('localVideo').srcObject = localStream;
        
        // Create peer connection
        await createPeerConnection();
        
        // Create and send offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        // Send offer to server
        const response = await fetch(`${API_URL}/call/offer`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            callerId: currentUserId,
            receiverId: selectedUserId,
            offer: offer,
            callType: callType
          })
        });
        
        const data = await response.json();
        currentCallId = data.callId;
        
        // Show outgoing call UI
        showOutgoingCallUI();
        startRingtone();
        
        // Start checking for call updates
        startCallPolling();
        
        // Slow down user list polling during call
        if (typeof updateUserListInterval === 'function') updateUserListInterval();
        
        isSettingUpCall = false;
        
      } catch (err) {
        console.error('Error starting call:', err);
        alert('Failed to access camera/microphone. Please check permissions.');
        isSettingUpCall = false;
        cleanupCall();
      }
    }
    
    // Accept incoming call
    async function acceptCall(call) {
      console.log('Accepting call:', call.id);
      
      if (isSettingUpCall) {
        console.log('Call setup already in progress');
        return;
      }
      
      isSettingUpCall = true;
      
      // Send immediate heartbeat to ensure session is active
      await sendHeartbeat();
      
      try {
        currentCallId = call.id;
        currentCallType = call.callType;
        
        stopRingtone();
        
        // Get user media
        const constraints = {
          audio: true,
          video: call.callType === 'video'
        };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        document.getElementById('localVideo').srcObject = localStream;
        
        // Create peer connection
        await createPeerConnection();
        
        // Set remote description from offer
        await peerConnection.setRemoteDescription(new RTCSessionDescription(call.offer));
        
        // Create and send answer
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        await fetch(`${API_URL}/call/answer`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            callId: currentCallId,
            answer: answer
          })
        });
        
        // Hide incoming UI and start polling
        document.getElementById('incomingCallUI').style.display = 'none';
        startCallPolling();
        
        // Slow down user list polling during call
        if (typeof updateUserListInterval === 'function') updateUserListInterval();
        
        isSettingUpCall = false;
        
      } catch (err) {
        console.error('Error accepting call:', err);
        alert('Failed to access camera/microphone. Please check permissions.');
        isSettingUpCall = false;
        currentCallId = null;
        rejectCall(call.id);
      }
    }
    
    // Reject incoming call
    async function rejectCall(callId) {
      console.log('Rejecting call:', callId);
      stopRingtone();
      
      try {
        await fetch(`${API_URL}/call/reject`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ callId })
        });
      } catch (err) {
        console.error('Error rejecting call:', err);
      }
      
      cleanupCall();
      hideCallModal();
    }
    
    // End active call
    async function endCall() {
      stopRingtone();
      playCallEnded();
      
      if (currentCallId) {
        try {
          await fetch(`${API_URL}/call/end`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ callId: currentCallId })
          });
        } catch (err) {
          console.error('Error ending call:', err);
        }
      }
      
      cleanupCall();
      hideCallModal();
    }
    
    // Cleanup call resources
    function cleanupCall() {
      console.log('Cleaning up call resources');
      
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      
      if (localStream) {
        localStream.getTracks().forEach(track => {
          track.stop();
          console.log('Stopped local track:', track.kind);
        });
        localStream = null;
      }
      
      if (remoteStream) {
        remoteStream.getTracks().forEach(track => {
          track.stop();
          console.log('Stopped remote track:', track.kind);
        });
        remoteStream = null;
      }
      
      // Clear video elements
      const localVideo = document.getElementById('localVideo');
      const remoteVideo = document.getElementById('remoteVideo');
      if (localVideo) localVideo.srcObject = null;
      if (remoteVideo) remoteVideo.srcObject = null;
      
      if (callCheckInterval) {
        clearInterval(callCheckInterval);
        callCheckInterval = null;
      }
      
      if (callDurationInterval) {
        clearInterval(callDurationInterval);
        callDurationInterval = null;
      }
      
      stopRingtone();
      currentCallId = null;
      currentCallType = null;
      lastIceCheckTimestamp = 0;
      isSettingUpCall = false;
      
      // Restore normal user list polling
      if (typeof updateUserListInterval === 'function') updateUserListInterval();
    }
    
    // Poll for call updates
    function startCallPolling() {
      if (callCheckInterval) return;
      
      let pollCount = 0;
      
      callCheckInterval = setInterval(async () => {
        try {
          // Send heartbeat every 10 poll cycles (10 seconds) during call
          pollCount++;
          if (pollCount % 10 === 0) {
            sendHeartbeat().catch(err => console.error('Call heartbeat failed:', err));
          }
          
          const response = await fetch(
            `${API_URL}/call/check/${currentUserId}?lastCheck=${lastIceCheckTimestamp}`,
            { signal: AbortSignal.timeout(3000) } // 3 second timeout
          );
          const data = await response.json();
          
          // Handle incoming call while in another call
          if (data.incomingCall && !currentCallId) {
            handleIncomingCall(data.incomingCall);
          }
          
          // Handle active call updates
          if (data.activeCall && currentCallId === data.activeCall.id && peerConnection) {
            console.log('Active call status:', data.activeCall.status);
            
            // Check if call has answer (for caller)
            if (data.activeCall.answer && !peerConnection.currentRemoteDescription) {
              try {
                console.log('Setting remote answer from receiver');
                await peerConnection.setRemoteDescription(
                  new RTCSessionDescription(data.activeCall.answer)
                );
                
                // If we're the caller and just got the answer, show active UI
                if (data.activeCall.callerId === currentUserId) {
                  stopRingtone();
                  // Don't call showActiveCallUI here, let onconnectionstatechange handle it
                }
              } catch (err) {
                console.error('Error setting remote description:', err);
              }
            }
            
            // Add new ICE candidates
            for (const ice of data.iceCandidates) {
              try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(ice.candidate));
                lastIceCheckTimestamp = ice.timestamp;
              } catch (err) {
                console.error('Error adding ICE candidate:', err);
              }
            }
          }
          
          // Check if call was ended remotely
          if (currentCallId && !data.activeCall && !data.incomingCall && !isSettingUpCall) {
            // Only end if we're actually connected
            if (peerConnection && (peerConnection.connectionState === 'connected' || 
                                   peerConnection.connectionState === 'connecting')) {
              console.log('Call ended remotely');
              endCall();
            }
          }
          
        } catch (err) {
          console.error('Error checking call status:', err);
        }
      }, 1000); // Check every second
    }
    
    // Handle incoming call notification
    function handleIncomingCall(call) {
      // Prevent duplicate handling
      if (currentCallId || document.getElementById('callModal').classList.contains('active')) {
        console.log('Ignoring duplicate incoming call');
        return;
      }
      
      console.log('Incoming call from:', call.callerId);
      
      // Set currentCallId immediately to prevent other checks from interfering
      currentCallId = call.id;
      currentCallType = call.callType;
      
      // Get caller info from user list
      const users = Array.from(document.querySelectorAll('.user'));
      const callerElement = users.find(u => u.dataset.userId === call.callerId);
      const callerName = callerElement ? callerElement.querySelector('span').textContent : 'Unknown';
      const callerPhoto = callerElement ? callerElement.querySelector('img').src : 'avater/luffy.jpg';
      
      document.getElementById('incomingCallAvatar').src = callerPhoto;
      document.getElementById('incomingCallName').textContent = callerName;
      document.getElementById('incomingCallType').textContent = 
        call.callType === 'video' ? 'Incoming video call...' : 'Incoming voice call...';
      
      document.getElementById('incomingCallUI').style.display = 'block';
      document.getElementById('callModal').classList.add('active');
      
      startRingtone();
      startCallPolling();
      
      // Setup accept/reject handlers
      document.getElementById('acceptCallBtn').onclick = () => acceptCall(call);
      document.getElementById('rejectCallBtn').onclick = () => {
        currentCallId = null; // Reset before rejecting
        rejectCall(call.id);
      };
    }
    
    // Show outgoing call UI
    function showOutgoingCallUI() {
      const users = Array.from(document.querySelectorAll('.user'));
      const receiverElement = users.find(u => u.dataset.userId === selectedUserId);
      const receiverName = receiverElement ? receiverElement.querySelector('span').textContent : 'Unknown';
      const receiverPhoto = receiverElement ? receiverElement.querySelector('img').src : 'avater/luffy.jpg';
      
      document.getElementById('outgoingCallAvatar').src = receiverPhoto;
      document.getElementById('outgoingCallName').textContent = receiverName;
      
      document.getElementById('outgoingCallUI').style.display = 'block';
      document.getElementById('callModal').classList.add('active');
      
      document.getElementById('cancelCallBtn').onclick = endCall;
    }
    
    // Show active call UI
    function showActiveCallUI() {
      // Prevent duplicate calls
      if (document.getElementById('activeCallUI').style.display === 'block') {
        console.log('Active call UI already shown');
        return;
      }
      
      console.log('Showing active call UI');
      
      // Get the other user's name
      let otherUserName = 'Unknown';
      
      if (selectedUserId) {
        const users = Array.from(document.querySelectorAll('.user'));
        const otherUserElement = users.find(u => u.dataset.userId === selectedUserId);
        otherUserName = otherUserElement ? 
          otherUserElement.querySelector('span').textContent : 'Unknown';
      } else {
        // For incoming calls, get name from incoming call UI
        const incomingName = document.getElementById('incomingCallName').textContent;
        if (incomingName) otherUserName = incomingName;
      }
      
      document.getElementById('activeCallName').textContent = otherUserName;
      
      // Show/hide video button based on call type
      if (currentCallType === 'video') {
        document.getElementById('videoBtn').style.display = 'block';
      }
      
      document.getElementById('incomingCallUI').style.display = 'none';
      document.getElementById('outgoingCallUI').style.display = 'none';
      document.getElementById('activeCallUI').style.display = 'block';
      
      // Setup control handlers
      document.getElementById('muteBtn').onclick = toggleMute;
      document.getElementById('videoBtn').onclick = toggleVideo;
      document.getElementById('endCallBtn').onclick = endCall;
    }
    
    // Hide call modal
    function hideCallModal() {
      document.getElementById('callModal').classList.remove('active');
      document.getElementById('incomingCallUI').style.display = 'none';
      document.getElementById('outgoingCallUI').style.display = 'none';
      document.getElementById('activeCallUI').style.display = 'none';
    }
    
    // Toggle mute
    function toggleMute() {
      if (!localStream) return;
      
      const audioTrack = localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        const muteBtn = document.getElementById('muteBtn');
        
        if (audioTrack.enabled) {
          muteBtn.classList.remove('active');
          muteBtn.querySelector('i').className = 'las la-microphone';
        } else {
          muteBtn.classList.add('active');
          muteBtn.querySelector('i').className = 'las la-microphone-slash';
        }
      }
    }
    
    // Toggle video
    function toggleVideo() {
      if (!localStream) return;
      
      const videoTrack = localStream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        const videoBtn = document.getElementById('videoBtn');
        
        if (videoTrack.enabled) {
          videoBtn.classList.remove('active');
          videoBtn.querySelector('i').className = 'las la-video';
        } else {
          videoBtn.classList.add('active');
          videoBtn.querySelector('i').className = 'las la-video-slash';
        }
      }
    }
    
    // Call duration timer
    function startCallDuration() {
      // Prevent starting multiple timers
      if (callDurationInterval) {
        console.log('Call duration timer already running');
        return;
      }
      
      callStartTime = Date.now();
      
      callDurationInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        
        document.getElementById('callDuration').textContent = 
          `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }, 1000);
    }
    
    // Add call buttons to chat header
    function addCallButtons() {
      const chatActions = document.querySelector('.chat-actions');
      if (chatActions && !document.getElementById('audioCallBtn')) {
        // Replace the call buttons with functional ones
        const buttons = chatActions.querySelectorAll('.icon-btn');
        if (buttons[0]) {
          buttons[0].id = 'audioCallBtn';
          buttons[0].onclick = () => startCall('audio');
        }
        if (buttons[1]) {
          buttons[1].id = 'videoCallBtn';
          buttons[1].onclick = () => startCall('video');
        }
      }
    }
    
    // ============ End WebRTC Functions ============
    
    // Initialize
    loadUsers();
    
    // Dynamic user list polling - slower during calls
    function updateUserListInterval() {
      if (userListInterval) clearInterval(userListInterval);
      
      const interval = currentCallId ? 10000 : 3000; // 10s during call, 3s normally
      userListInterval = setInterval(loadUsers, interval);
    }
    
    updateUserListInterval();
    
    // Check for incoming calls
    setInterval(async () => {
      // Only check if not in a call AND modal is not active
      const callModalActive = document.getElementById('callModal').classList.contains('active');
      
      if (!currentCallId && !callModalActive) {
        try {
          const response = await fetch(`${API_URL}/call/check/${currentUserId}`);
          const data = await response.json();
          
          if (data.incomingCall) {
            handleIncomingCall(data.incomingCall);
          }
        } catch (err) {
          console.error('Error checking for calls:', err);
        }
      }
    }, 2000); // Check every 2 seconds
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (userListInterval) clearInterval(userListInterval);
      if (messagesInterval) clearInterval(messagesInterval);
      if (currentCallId) endCall();
      cleanupCall();
    });
  </script>
</body>
</html>
